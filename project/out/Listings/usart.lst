C51 COMPILER V9.59.0.0   USART                                                             03/07/2021 19:22:28 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE USART
OBJECT MODULE PLACED IN .\out\usart.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\device\usart.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\application;..\devi
                    -ce) DEBUG OBJECTEXTEND PRINT(.\out\Listings\usart.lst) OBJECT(.\out\usart.obj)

line level    source

   1          
   2          #include "usart.h"
   3          #include        "delay.h"
   4          
   5          
   6          
   7          
   8          
   9          #ifdef USING_UART1
  10          static uint8_t  xdata TX1_Buffer[COM_TX1_Lenth];        //∑¢ÀÕª∫≥Â
  11          static uint8_t  xdata RX1_Buffer[COM_RX1_Lenth];        //Ω” ’ª∫≥Â
  12          #endif
  13          #ifdef USING_UART2
  14          static uint8_t  xdata TX2_Buffer[COM_TX2_Lenth];        //∑¢ÀÕª∫≥Â
  15          static uint8_t  xdata RX2_Buffer[COM_RX2_Lenth];        //Ω” ’ª∫≥Â
  16          #endif
  17          #ifdef USING_UART3
              static uint8_t  xdata TX3_Buffer[COM_TX3_Lenth];        //∑¢ÀÕª∫≥Â
              static uint8_t  xdata RX3_Buffer[COM_RX3_Lenth];        //Ω” ’ª∫≥Â
              #endif
  21          #ifdef USING_UART4
              static uint8_t  xdata TX4_Buffer[COM_TX4_Lenth];        //∑¢ÀÕª∫≥Â
              static uint8_t  xdata RX4_Buffer[COM_RX4_Lenth];        //Ω” ’ª∫≥Â
              #endif
  25          
  26          static uint8_t xdata  uart_init = 0;
  27          
  28          
  29          static COMx_Define xdata Uartx_config[]=
  30          {
  31              #ifdef USING_UART1
  32                  {1,RX1_Buffer,TX1_Buffer,COM_RX1_Lenth,COM_TX1_Lenth,0,0,0,0,0,0,0},
  33              #endif
  34              #ifdef USING_UART2
  35                  {2,RX2_Buffer,TX2_Buffer,COM_RX2_Lenth,COM_TX2_Lenth,0,0,0,0,0,0,0},
  36              #endif
  37              #ifdef USING_UART3
                      {3,RX3_Buffer,TX3_Buffer,COM_RX3_Lenth,COM_TX3_Lenth,0,0,0,0,0,0,0},
                  #endif
  40              #ifdef USING_UART4
                      {4,RX4_Buffer,TX4_Buffer,COM_RX4_Lenth,COM_TX4_Lenth,0,0,0,0,0,0,0},
                  #endif
  43          };
  44          
  45          static void USART_Hook()
  46          {
  47   1          uint8_t i;
  48   1          for(i=0;i<sizeof(Uartx_config)/sizeof(Uartx_config[0]);i++)
  49   1          {
  50   2              if(Uartx_config[i].RX_TimeOut > 0)
  51   2              {
  52   3                  Uartx_config[i].RX_TimeOut--;
  53   3                  if(Uartx_config[i].RX_TimeOut==0)
  54   3                  {
C51 COMPILER V9.59.0.0   USART                                                             03/07/2021 19:22:28 PAGE 2   

  55   4                      if(Uartx_config[i].timer_out_cb)
  56   4                      {
  57   5                          Uartx_config[i].timer_out_cb();
  58   5                      }
  59   4                  }
  60   3              }
  61   2          }
  62   1      }
  63          void USART_Set_rx_timer_out_cb(uint8_t UARTx, usart_rx_timer_out_cb_t timer_out_cb,uint8_t RX_TimeOut)//…Ë
             -÷√≥¨ ±Õ®÷™ªÿµ˜
  64          {
  65   1          Uartx_config[UARTx].timer_out_cb = timer_out_cb;
  66   1          Uartx_config[UARTx].RX_TimeOut = RX_TimeOut;
  67   1      }
  68          int8_t USART_Configuration(uint8_t UARTx, COMx_InitDefine *COMx)
  69          {
  70   1              uint8_t i;
  71   1              uint32_t        j;
  72   1          
  73   1          Uartx_config[UARTx].TX_read = 0;
  74   1          Uartx_config[UARTx].TX_write = 0;
  75   1          Uartx_config[UARTx].B_TX_busy = 0;
  76   1          Uartx_config[UARTx].RX_Front = 0;
  77   1          Uartx_config[UARTx].RX_Rear = 0;
  78   1          Uartx_config[UARTx].RX_RxCnt = 0;
  79   1          Uartx_config[UARTx].timer_out_cb = NULL;
  80   1          if(COMx->RX_TimeOut == 0)
  81   1          {
  82   2              Uartx_config[UARTx].RX_TimeOut = 0;
  83   2          }
  84   1          else
  85   1          {
  86   2              Uartx_config[UARTx].RX_TimeOut = COMx->RX_TimeOut;
  87   2          }
  88   1          if(uart_init==0)
  89   1          {
  90   2              delay_add_hook(USART_Hook);
  91   2              uart_init = 1;
  92   2          }
  93   1      #ifdef USING_UART1
  94   1              if(UARTx == USART1)
  95   1              {
  96   2      
  97   2                      for(i=0; i<COM_TX1_Lenth; i++)  TX1_Buffer[i] = 0;
  98   2                      for(i=0; i<COM_RX1_Lenth; i++)  RX1_Buffer[i] = 0;
  99   2      
 100   2                      if(COMx->UART_Mode > UART_9bit_BRTx)    return 2;       //ƒ£ Ω¥ÌŒÛ
 101   2                      if(COMx->UART_Polity == PolityHigh)             PS = 1; //∏ﬂ”≈œ»º∂÷–∂œ
 102   2                      else                                                                    PS = 0; //µÕ”≈œ»º∂÷–∂œ
 103   2                      SCON = (SCON & 0x3f) | COMx->UART_Mode;
 104   2                      if((COMx->UART_Mode == UART_9bit_BRTx) ||(COMx->UART_Mode == UART_8bit_BRTx))   //ø…±‰≤®Ãÿ¬ 
 105   2                      {
 106   3      
 107   3                  j = (MAIN_Fosc / COMx->UART_BaudRate) / 4;  //∞¥1Tº∆À„
 108   3      
 109   3                  if(j >= 65536UL)    return 2;       //¥ÌŒÛ
 110   3                  j = 65536UL - j;
 111   3                  
 112   3                  
 113   3      
 114   3                              if(COMx->UART_BRT_Use == BRT_Timer1)
 115   3                              {
C51 COMPILER V9.59.0.0   USART                                                             03/07/2021 19:22:28 PAGE 3   

 116   4                                      TR1 = 0;
 117   4                                      AUXR &= ~0x01;          //S1 BRT Use Timer1;
 118   4                                      TMOD &= ~(1<<6);        //Timer1 set As Timer
 119   4                                      TMOD &= ~0x30;          //Timer1_16bitAutoReload;
 120   4                      AUXR |=  (1<<6);        //Timer1 set as 1T mode
 121   4                                      TH1 = (uint8_t)(j>>8);
 122   4                                      TL1 = (uint8_t)j;
 123   4                                      ET1 = 0;        //Ω˚÷π÷–∂œ
 124   4                                      TMOD &= ~0x40;  //∂® ±
 125   4                                      INT_CLKO &= ~0x02;      //≤ª ‰≥ˆ ±÷”
 126   4                                      TR1  = 1;
 127   4                              }
 128   3                              else if(COMx->UART_BRT_Use == BRT_Timer2)
 129   3                              {
 130   4                                      AUXR &= ~(1<<4);        //Timer stop
 131   4                                      AUXR |= 0x01;           //S1 BRT Use Timer2;
 132   4                                      AUXR &= ~(1<<3);        //Timer2 set As Timer
 133   4                      AUXR |=  (1<<2);        //Timer2 set as 1T mode
 134   4                                      T2H = (uint8_t)(j>>8);
 135   4                                      T2L = (uint8_t)j;
 136   4                                      IE2  &= ~(1<<2);        //Ω˚÷π÷–∂œ
 137   4                                      AUXR &= ~(1<<3);        //∂® ±
 138   4                                      AUXR |=  (1<<4);        //Timer run enable
 139   4                              }
 140   3                              else return 2;  //¥ÌŒÛ
 141   3                      }
 142   2                      else if(COMx->UART_Mode == UART_ShiftRight)
 143   2                      {
 144   3                              if(COMx->BaudRateDouble == ENABLE)      AUXR |=  (1<<5);        //πÃ∂®≤®Ãÿ¬ SysClk/2
 145   3                              else                                                            AUXR &= ~(1<<5);        //πÃ∂®≤®Ãÿ¬ SysClk/12
 146   3                      }
 147   2                      else if(COMx->UART_Mode == UART_9bit)   //πÃ∂®≤®Ãÿ¬ SysClk*2^SMOD/64
 148   2                      {
 149   3                              if(COMx->BaudRateDouble == ENABLE)      PCON |=  (1<<7);        //πÃ∂®≤®Ãÿ¬ SysClk/32
 150   3                              else                                                            PCON &= ~(1<<7);        //πÃ∂®≤®Ãÿ¬ SysClk/64
 151   3                      }
 152   2              if(COMx->Morecommunicate == ENABLE) SCON |=  (1<<5);
 153   2              else                                SCON &= ~(1<<5);
 154   2                      if(COMx->UART_Interrupt == ENABLE)      ES = 1; //‘ –Ì÷–∂œ
 155   2                      else                                                            ES = 0; //Ω˚÷π÷–∂œ
 156   2                      if(COMx->UART_RxEnable == ENABLE)       REN = 1;        //‘ –ÌΩ” ’
 157   2                      else                                                            REN = 0;        //Ω˚÷πΩ” ’
 158   2                      P_SW1 = (P_SW1 & 0x3f) | (COMx->UART_P_SW & 0xc0);      //«–ªªIO
 159   2                      if(COMx->UART_RXD_TXD_Short == ENABLE)  PCON2 |=  (1<<4);       //ƒ⁄≤ø∂Ã¬∑RXD”ÎTXD, ◊ˆ÷–ºÃ, ENABLE,DISABLE
 160   2                      else                                                                    PCON2 &= ~(1<<4);
 161   2                      return  0;
 162   2              }
 163   1      #endif
 164   1      #ifdef USING_UART2
 165   1              if(UARTx == USART2)
 166   1              {
 167   2      
 168   2                      for(i=0; i<COM_TX2_Lenth; i++)  TX2_Buffer[i] = 0;
 169   2                      for(i=0; i<COM_RX2_Lenth; i++)  RX2_Buffer[i] = 0;
 170   2      
 171   2                      if((COMx->UART_Mode == UART_9bit_BRTx) ||(COMx->UART_Mode == UART_8bit_BRTx))   //ø…±‰≤®Ãÿ¬ 
 172   2                      {
 173   3                              if(COMx->UART_Polity == PolityHigh)             IP2 |=  1;      //∏ﬂ”≈œ»º∂÷–∂œ
 174   3                              else                                                                    IP2 &= ~1;      //µÕ”≈œ»º∂÷–∂œ
 175   3                              if(COMx->UART_Mode == UART_9bit_BRTx)   S2CON |=  (1<<7);       //9bit
 176   3                              else                                                                    S2CON &= ~(1<<7);       //8bit
 177   3                              j = (MAIN_Fosc / 4) / COMx->UART_BaudRate;      //∞¥1Tº∆À„
C51 COMPILER V9.59.0.0   USART                                                             03/07/2021 19:22:28 PAGE 4   

 178   3                              if(j >= 65536UL)        return 2;       //¥ÌŒÛ
 179   3                              j = 65536UL - j;
 180   3                  if(COMx->UART_BRT_Use != BRT_Timer2) return 2;      //ƒ£ Ω¥ÌŒÛ
 181   3                              AUXR &= ~(1<<4);        //Timer stop
 182   3                              AUXR &= ~(1<<3);        //Timer2 set As Timer
 183   3                              AUXR |=  (1<<2);        //Timer2 set as 1T mode
 184   3                              T2H = (uint8_t)(j>>8);
 185   3                              T2L = (uint8_t)j;
 186   3                              IE2  &= ~(1<<2);        //Ω˚÷π÷–∂œ
 187   3                              AUXR |=  (1<<4);        //Timer run enable
 188   3                      }
 189   2                      else    return 2;       //ƒ£ Ω¥ÌŒÛ
 190   2              if(COMx->Morecommunicate == ENABLE) S2CON |=  (1<<5);
 191   2              else                                S2CON &= ~(1<<5);
 192   2                      if(COMx->UART_Interrupt == ENABLE)      IE2   |=  1;            //‘ –Ì÷–∂œ
 193   2                      else                                                            IE2   &= ~1;            //Ω˚÷π÷–∂œ
 194   2                      if(COMx->UART_RxEnable == ENABLE)       S2CON |=  (1<<4);       //‘ –ÌΩ” ’
 195   2                      else                                                            S2CON &= ~(1<<4);       //Ω˚÷πΩ” ’
 196   2                      P_SW2 = (P_SW2 & ~1) | (COMx->UART_P_SW & 0x01);        //«–ªªIO
 197   2              }
 198   1      #endif
 199   1      #ifdef USING_UART3
                      if(UARTx == USART3)
                      {
              
                              for(i=0; i<COM_TX3_Lenth; i++)  TX3_Buffer[i] = 0;
                              for(i=0; i<COM_RX3_Lenth; i++)  RX3_Buffer[i] = 0;
              
                              if((COMx->UART_Mode == UART_9bit_BRTx) || (COMx->UART_Mode == UART_8bit_BRTx))  //ø…±‰≤®Ãÿ¬ 
                              {
              
                                      if(COMx->UART_Mode == UART_9bit_BRTx)   S3CON |=  (1<<7);       //9bit
                                      else                                                                    S3CON &= ~(1<<7);       //8bit
                                      j = (MAIN_Fosc / 4) / COMx->UART_BaudRate;      //∞¥1Tº∆À„
                                      if(j >= 65536UL)        return 2;       //¥ÌŒÛ
                                      j = 65536UL - j;
                                      if(COMx->UART_BRT_Use == BRT_Timer2)
                                      {
                              AUXR &= ~(1<<4);        //Timer stop
                              S3CON &= ~0x40;         //S3 BRT Use Timer2;
                              AUXR &= ~(1<<3);        //Timer2 set As Timer
                              AUXR |=  (1<<2);        //Timer2 set as 1T mode
                              T2H = (uint8_t)(j>>8);
                              T2L = (uint8_t)j;
                              IE2  &= ~(1<<2);        //Ω˚÷π÷–∂œ
                              AUXR |=  (1<<4);        //Timer run enable
                          }
                          else if(COMx->UART_BRT_Use == BRT_Timer3)
                          {
                              T3T4M &=  ~(1<<3);      //Timer stop
                              S3CON |= 0x40;          //S3 BRT Use Timer3;
                              T3T4M &= ~(1<<2);       //Timer3 set As Timer
                              T3T4M |=  (1<<1);       //Timer3 set as 1T mode
                              T3H = (uint8_t)(j>>8);
                              T3L = (uint8_t)j;
                              IE2  &= ~(1<<5);        //Ω˚÷π÷–∂œ
                              T3T4M |=  (1<<3);       //Timer run enable
                          }
                          else
                          {
                              return 2;       //ƒ£ Ω¥ÌŒÛ
                          }
C51 COMPILER V9.59.0.0   USART                                                             03/07/2021 19:22:28 PAGE 5   

              
                              }
                              else    return 2;       //ƒ£ Ω¥ÌŒÛ
                      if(COMx->Morecommunicate == ENABLE) S3CON |=  (1<<5);
                      else                                S3CON &= ~(1<<5);
                              if(COMx->UART_Interrupt == ENABLE)      IE2   |=  (1<<3);               //‘ –Ì÷–∂œ
                              else                                                            IE2   &= ~(1<<3);               //Ω˚÷π÷–∂œ
                              if(COMx->UART_RxEnable == ENABLE)       S3CON |=  (1<<4);       //‘ –ÌΩ” ’
                              else                                                            S3CON &= ~(1<<4);       //Ω˚÷πΩ” ’
                              P_SW2 = (P_SW2 & ~(1<<1)) | ((COMx->UART_P_SW & 0x01)<<1);      //«–ªªIO
                      }
              #endif
 252   1      #ifdef USING_UART4
                      if(UARTx == USART4)
                      {
              
                              for(i=0; i<COM_TX4_Lenth; i++)  TX4_Buffer[i] = 0;
                              for(i=0; i<COM_RX4_Lenth; i++)  RX4_Buffer[i] = 0;
              
                              if((COMx->UART_Mode == UART_9bit_BRTx) ||(COMx->UART_Mode == UART_8bit_BRTx))   //ø…±‰≤®Ãÿ¬ 
                              {
                                      if(COMx->UART_Mode == UART_9bit_BRTx)   S4CON |=  (1<<7);       //9bit
                                      else                                                                    S4CON &= ~(1<<7);       //8bit
                                      j = (MAIN_Fosc / 4) / COMx->UART_BaudRate;      //∞¥1Tº∆À„
                                      if(j >= 65536UL)        return 2;       //¥ÌŒÛ
                                      j = 65536UL - j;
                                      if(COMx->UART_BRT_Use == BRT_Timer2)
                                      {
                              AUXR &= ~(1<<4);        //Timer stop
                              S4CON &= ~0x40;         //S3 BRT Use Timer2;
                              AUXR &= ~(1<<3);        //Timer2 set As Timer
                              AUXR |=  (1<<2);        //Timer2 set as 1T mode
                              T2H = (uint8_t)(j>>8);
                              T2L = (uint8_t)j;
                              IE2  &= ~(1<<2);        //Ω˚÷π÷–∂œ
                              AUXR |=  (1<<4);        //Timer run enable
                          }
                          else if(COMx->UART_BRT_Use == BRT_Timer4)
                          {
                              T3T4M &=  ~(1<<7);      //Timer stop
                              S4CON |= 0x40;          //S3 BRT Use Timer4;
                              T3T4M &= ~(1<<6);       //Timer4 set As Timer
                              T3T4M |=  (1<<5);       //Timer4 set as 1T mode
                              T4H = (uint8_t)(j>>8);
                              T4L = (uint8_t)j;
                              IE2  &= ~(1<<6);        //Ω˚÷π÷–∂œ
                              T3T4M |=  (1<<7);       //Timer run enable
                          }
                          else
                          {
                              return 2;       //ƒ£ Ω¥ÌŒÛ
                          }
                          
                              }
                              else    return 2;       //ƒ£ Ω¥ÌŒÛ
                      if(COMx->Morecommunicate == ENABLE) S4CON |=  (1<<5);
                      else                                S4CON &= ~(1<<5);
                              if(COMx->UART_Interrupt == ENABLE)      IE2   |=  (1<<4);               //‘ –Ì÷–∂œ
                              else                                                            IE2   &= ~(1<<4);               //Ω˚÷π÷–∂œ
                              if(COMx->UART_RxEnable == ENABLE)       S4CON |=  (1<<4);       //‘ –ÌΩ” ’
                              else                                                            S4CON &= ~(1<<4);       //Ω˚÷πΩ” ’
                              P_SW2 = (P_SW2 & ~(1<<2)) | ((COMx->UART_P_SW & 0x01)<<2);      //«–ªªIO
C51 COMPILER V9.59.0.0   USART                                                             03/07/2021 19:22:28 PAGE 6   

                      }
              #endif
 304   1          return 0;
 305   1      }
 306          
 307          
 308          /*************** ◊∞‘ÿ¥Æø⁄∑¢ÀÕª∫≥Â *******************************/
 309          #ifdef USING_UART1
 310          void TX1_write2buff(uint8_t dat)        //–¥»Î∑¢ÀÕª∫≥Â£¨÷∏’Î+1
 311          {
 312   1              TX1_Buffer[Uartx_config[USART1].TX_write] = dat;        //◊∞∑¢ÀÕª∫≥Â
 313   1              if(++Uartx_config[USART1].TX_write >= COM_TX1_Lenth)    Uartx_config[USART1].TX_write = 0;
 314   1      
 315   1              if(Uartx_config[USART1].B_TX_busy == 0)         //ø’œ–
 316   1              {  
 317   2                      Uartx_config[USART1].B_TX_busy = 1;             //±Í÷æ√¶
 318   2                      TI = 1;                                 //¥•∑¢∑¢ÀÕ÷–∂œ
 319   2              }
 320   1      }
 321          #endif
 322          #ifdef USING_UART2
 323          void TX2_write2buff(uint8_t dat)        //–¥»Î∑¢ÀÕª∫≥Â£¨÷∏’Î+1
 324          {
 325   1          
 326   1              TX2_Buffer[Uartx_config[USART2].TX_write] = dat;        //◊∞∑¢ÀÕª∫≥Â
 327   1              if(++Uartx_config[USART2].TX_write >= COM_TX2_Lenth)    Uartx_config[USART2].TX_write = 0;
 328   1      
 329   1              if(Uartx_config[USART2].B_TX_busy == 0)         //ø’œ–
 330   1              {  
 331   2                      Uartx_config[USART2].B_TX_busy = 1;             //±Í÷æ√¶
 332   2                      S2CON |=  2;                            //¥•∑¢∑¢ÀÕ÷–∂œ
 333   2              }
 334   1      }
 335          #endif
 336          #ifdef USING_UART3
              void TX3_write2buff(uint8_t dat)        //–¥»Î∑¢ÀÕª∫≥Â£¨÷∏’Î+1
              {
                  
                      TX3_Buffer[Uartx_config[USART3].TX_write] = dat;        //◊∞∑¢ÀÕª∫≥Â
                      if(++Uartx_config[USART3].TX_write >= COM_TX3_Lenth)    Uartx_config[USART3].TX_write = 0;
              
                      if(Uartx_config[USART3].B_TX_busy == 0)         //ø’œ–
                      {  
                              Uartx_config[USART3].B_TX_busy = 1;             //±Í÷æ√¶
                              S3CON |=  2;                            //¥•∑¢∑¢ÀÕ÷–∂œ
                      }
              }
              #endif
 350          #ifdef USING_UART4
              void TX4_write2buff(uint8_t dat)        //–¥»Î∑¢ÀÕª∫≥Â£¨÷∏’Î+1
              {
                  
                      TX4_Buffer[Uartx_config[USART4].TX_write] = dat;        //◊∞∑¢ÀÕª∫≥Â
                      if(++Uartx_config[USART4].TX_write >= COM_TX4_Lenth)    Uartx_config[USART4].TX_write = 0;
              
                      if(Uartx_config[USART4].B_TX_busy == 0)         //ø’œ–
                      {  
                              Uartx_config[USART4].B_TX_busy = 1;             //±Í÷æ√¶
                              S4CON |=  2;                            //¥•∑¢∑¢ÀÕ÷–∂œ
                      }
              }
              #endif
C51 COMPILER V9.59.0.0   USART                                                             03/07/2021 19:22:28 PAGE 7   

 364          
 365          void UARTx_writebuff(enum USARTx com, uint8_t dat)      //–¥»Î∑¢ÀÕª∫≥Â£¨÷∏’Î+1
 366          {
 367   1          #ifdef USING_UART1
 368   1              if(Uartx_config[com].id == 1)   TX1_write2buff(dat);
 369   1          #endif
 370   1          #ifdef USING_UART2
 371   1              if(Uartx_config[com].id == 2)   TX2_write2buff(dat);
 372   1          #endif
 373   1          #ifdef USING_UART3
                      if(Uartx_config[com].id == 3)   TX3_write2buff(dat);
                  #endif
 376   1          #ifdef USING_UART4
                      if(Uartx_config[com].id == 4)   TX4_write2buff(dat);
                  #endif
 379   1      }
 380          uint8_t UARTx_ReadRxLen(enum USARTx com)
 381          {
 382   1          return Uartx_config[com].RX_RxCnt;
 383   1      }
 384          int8_t UARTx_ReadRxChar(enum USARTx com,uint8_t *dat)
 385          {
 386   1          if(Uartx_config[com].RX_Front != Uartx_config[com].RX_Rear)
 387   1          {
 388   2              *dat = Uartx_config[com].Rx_buff[Uartx_config[com].RX_Front];
 389   2              Uartx_config[com].RX_Front = (Uartx_config[com].RX_Front+1)%Uartx_config[com].RX_BuffLen;
 390   2              Uartx_config[com].RX_RxCnt--;
 391   2              return 0;
 392   2          }
 393   1          return  -1;
 394   1          
 395   1      }
 396          int8_t UARTx_CheckRxChar(enum USARTx com,uint8_t *dat)//≤¢≤ª¥”∂”¡–¿Ô»°≥ˆ ˝æ›÷ª «≤Èø¥“ªœ¬ ˝æ›
 397          {
 398   1          if(Uartx_config[com].RX_Front != Uartx_config[com].RX_Rear)
 399   1          {
 400   2              *dat = Uartx_config[com].Rx_buff[Uartx_config[com].RX_Front];
 401   2              return 0;
 402   2          }
 403   1      
 404   1          return  -1;
 405   1          
 406   1      }
 407          
 408          
 409          int8_t UARTx_CheckPosRxBuff(enum USARTx com,uint8_t pos,uint8_t *buff,uint8_t len)//≤¢≤ª¥”∂”¡–¿Ô»°≥ˆ ˝æ›÷ª
             - «≤Èø¥“ªœ¬ ˝æ›
 410          {
 411   1          uint8_t i=0;
 412   1      
 413   1          if(Uartx_config[com].RX_RxCnt <= 0 || len <= 0 || (pos+len) > Uartx_config[com].RX_RxCnt)
 414   1          {
 415   2              return -1;
 416   2          }
 417   1          if((Uartx_config[com].RX_Front + pos + len ) / (Uartx_config[com].RX_BuffLen) >= 1)
 418   1          {
 419   2              if((Uartx_config[com].RX_Front + pos) / (Uartx_config[com].RX_BuffLen) >= 1)
 420   2              {
 421   3                  for(i=0;i<len;i++)
 422   3                  {
 423   4                      buff[i] = Uartx_config[com].Rx_buff[(Uartx_config[com].RX_Front + pos)%(Uartx_config[com].
             -RX_BuffLen) + i];
C51 COMPILER V9.59.0.0   USART                                                             03/07/2021 19:22:28 PAGE 8   

 424   4                  }
 425   3              }
 426   2              else
 427   2              {
 428   3      
 429   3                  for(i=0;i<Uartx_config[com].RX_BuffLen - (Uartx_config[com].RX_Front + pos);i++)
 430   3                  {
 431   4                      buff[i] = Uartx_config[com].Rx_buff[(Uartx_config[com].RX_Front + pos) + i];
 432   4                  }
 433   3                  for(i=0;i<(Uartx_config[com].RX_Front + pos + len)%Uartx_config[com].RX_BuffLen;i++)
 434   3                  {
 435   4                      buff[Uartx_config[com].RX_BuffLen - (Uartx_config[com].RX_Front + pos) + i] = Uartx_config
             -[com].Rx_buff[i];
 436   4                  }
 437   3              }
 438   2      
 439   2              
 440   2          }
 441   1          else
 442   1          {
 443   2              for(i=0;i<len;i++)
 444   2              {
 445   3                  buff[i] = Uartx_config[com].Rx_buff[Uartx_config[com].RX_Front+pos+i];
 446   3              }
 447   2          }
 448   1          return 0;  
 449   1      }
 450          int8_t UARTx_CheckRxBuff(enum USARTx com,uint8_t *buff,uint8_t len)//≤¢≤ª¥”∂”¡–¿Ô»°≥ˆ ˝æ›÷ª «≤Èø¥“ªœ¬ ˝æ›
 451          {
 452   1          uint8_t i=0;
 453   1          if(Uartx_config[com].RX_RxCnt <=len)
 454   1          {
 455   2              for(i=0;i<len;i++)
 456   2              {
 457   3                  buff[i] = Uartx_config[com].Rx_buff[(Uartx_config[com].RX_Front + i)%(Uartx_config[com].RX_Buf
             -fLen)];
 458   3              }
 459   2              return 0;
 460   2          }
 461   1          return -1;
 462   1      }
 463          int8_t UARTx_RemoveRxBuff(enum USARTx com,uint8_t len)
 464          {
 465   1          if(Uartx_config[com].RX_RxCnt <=len)
 466   1          {
 467   2              Uartx_config[com].RX_Front = (Uartx_config[com].RX_Front + len) % (Uartx_config[com].RX_BuffLen);
 468   2              Uartx_config[com].RX_RxCnt=Uartx_config[com].RX_RxCnt-len;
 469   2              return 0;
 470   2          }
 471   1          return -1;
 472   1          
 473   1      }
 474          void PrintString(enum USARTx com, uint8_t *puts)
 475          {
 476   1          for (; *puts != 0;  puts++)  UARTx_writebuff(com,*puts);    //”ˆµΩÕ£÷π∑˚0Ω· ¯
 477   1      }
 478          
 479          
 480          #ifdef USING_UART1
 481          /********************* UART1÷–∂œ∫Ø ˝************************/
 482          void UART1_int (void) interrupt UART1_VECTOR
 483          {
C51 COMPILER V9.59.0.0   USART                                                             03/07/2021 19:22:28 PAGE 9   

 484   1              if(RI)
 485   1              {
 486   2                      RI = 0;
 487   2              if(((Uartx_config[USART1].RX_Rear+1) % COM_RX1_Lenth) != Uartx_config[USART1].RX_Front)//∂”¡–√ª”–¬
             -˙
 488   2                      {
 489   3                              RX1_Buffer[Uartx_config[USART1].RX_Rear] = SBUF;
 490   3                  Uartx_config[USART1].RX_RxCnt++;
 491   3                  Uartx_config[USART1].RX_Rear =(Uartx_config[USART1].RX_Rear +1) % COM_RX1_Lenth;
 492   3                              Uartx_config[USART1].RX_TimeOut = Uartx_config[USART1].RX_TimeOut;;
 493   3                      }
 494   2              else if(Uartx_config[USART1].timer_out_cb)
 495   2              {
 496   3                  Uartx_config[USART1].timer_out_cb();
 497   3              }
 498   2              }
 499   1      
 500   1              if(TI)
 501   1              {
 502   2                      TI = 0;
 503   2                      if(Uartx_config[USART1].TX_read != Uartx_config[USART1].TX_write)
 504   2                      {
 505   3                              SBUF = TX1_Buffer[Uartx_config[USART1].TX_read];
 506   3                              if(++Uartx_config[USART1].TX_read >= COM_TX1_Lenth)             Uartx_config[USART1].TX_read = 0;
 507   3                      }
 508   2                      else    Uartx_config[USART1].B_TX_busy = 0;
 509   2              }
 510   1      }
 511          #endif
 512          #ifdef USING_UART2
 513          /********************* UART2÷–∂œ∫Ø ˝************************/
 514          void UART2_int (void) interrupt UART2_VECTOR
 515          {
 516   1              if((S2CON & 1) != 0)
 517   1              {
 518   2                      S2CON &= ~1;
 519   2              if(((Uartx_config[USART2].RX_Rear+1) % COM_RX2_Lenth) != Uartx_config[USART2].RX_Front)//∂”¡–√ª”–¬
             -˙
 520   2                      {
 521   3                              RX2_Buffer[Uartx_config[USART2].RX_Rear] = S2BUF;
 522   3                  Uartx_config[USART2].RX_RxCnt++;
 523   3                  Uartx_config[USART2].RX_Rear =(Uartx_config[USART2].RX_Rear +1) % COM_RX2_Lenth;
 524   3                              Uartx_config[USART2].RX_TimeOut = Uartx_config[USART2].RX_TimeOut;
 525   3                      }
 526   2              else if(Uartx_config[USART2].timer_out_cb)
 527   2              {
 528   3                  Uartx_config[USART2].timer_out_cb();
 529   3              }
 530   2              }
 531   1      
 532   1              if((S2CON & 2) != 0)
 533   1              {
 534   2                      S2CON &= ~2;
 535   2                      if(Uartx_config[USART2].TX_read != Uartx_config[USART2].TX_write)
 536   2                      {
 537   3                              S2BUF = TX2_Buffer[Uartx_config[USART2].TX_read];
 538   3                              if(++Uartx_config[USART2].TX_read >= COM_TX2_Lenth)             Uartx_config[USART2].TX_read = 0;
 539   3                      }
 540   2                      else    Uartx_config[USART2].B_TX_busy = 0;
 541   2              }
 542   1      
 543   1      }
C51 COMPILER V9.59.0.0   USART                                                             03/07/2021 19:22:28 PAGE 10  

 544          #endif
 545          #ifdef USING_UART3
              /********************* UART3÷–∂œ∫Ø ˝************************/
              void UART3_int (void) interrupt UART3_VECTOR
              {
                      if((S3CON & 1) != 0)
                      {
                              S3CON &= ~1;
                      if(((Uartx_config[USART3].RX_Rear+1) % COM_RX3_Lenth) != Uartx_config[USART3].RX_Front)//∂”¡–√ª”–¬
             -˙
                              {
                                      RX3_Buffer[Uartx_config[USART3].RX_Rear] = S3BUF;
                          Uartx_config[USART3].RX_RxCnt++;
                          Uartx_config[USART3].RX_Rear =(Uartx_config[USART3].RX_Rear +1) % COM_RX3_Lenth;
                                      Uartx_config[USART3].RX_TimeOut = Uartx_config[USART3].RX_TimeOut;
                              }
                      else if(Uartx_config[USART3].timer_out_cb)
                      {
                          Uartx_config[USART3].timer_out_cb();
                      }
                      }
              
                      if((S3CON & 2) != 0)
                      {
                              S3CON &= ~2;
                              if(Uartx_config[USART3].TX_read != Uartx_config[USART3].TX_write)
                              {
                                      S3BUF = TX3_Buffer[Uartx_config[USART3].TX_read];
                                      if(++Uartx_config[USART3].TX_read >= COM_TX3_Lenth)             Uartx_config[USART3].TX_read = 0;
                              }
                              else    Uartx_config[USART3].B_TX_busy = 0;
                      }
              }
              #endif
 577          #ifdef USING_UART4
              /********************* UART4÷–∂œ∫Ø ˝************************/
              void UART4_int (void) interrupt UART4_VECTOR
              {
                      if((S4CON & 1) != 0)
                      {
                              S4CON &= ~1;
                      if(((Uartx_config[USART4].RX_Rear+1) % COM_RX4_Lenth) != Uartx_config[USART4].RX_Front)//∂”¡–√ª”–¬
             -˙
                              {
                                      RX4_Buffer[Uartx_config[USART4].RX_Rear] = S4BUF;
                          Uartx_config[USART4].RX_RxCnt++;
                          Uartx_config[USART4].RX_Rear =(Uartx_config[USART4].RX_Rear +1) % COM_RX4_Lenth;
                                      Uartx_config[USART4].RX_TimeOut = Uartx_config[USART4].RX_TimeOut;
                              }
                      else if(Uartx_config[USART4].timer_out_cb)
                      {
                          Uartx_config[USART4].timer_out_cb();
                      }
                      }
              
                      if((S4CON & 2) != 0)
                      {
                              S4CON &= ~2;
                              if(Uartx_config[USART4].TX_read != Uartx_config[USART4].TX_write)
                              {
                                      S4BUF = TX4_Buffer[Uartx_config[USART4].TX_read];
                                      if(++Uartx_config[USART4].TX_read >= COM_TX4_Lenth)             Uartx_config[USART4].TX_read = 0;
C51 COMPILER V9.59.0.0   USART                                                             03/07/2021 19:22:28 PAGE 11  

                              }
                              else    Uartx_config[USART4].B_TX_busy = 0;
                      }
              }
              #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2830    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    551    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      33
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
