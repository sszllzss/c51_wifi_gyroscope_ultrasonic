C51 COMPILER V9.59.0.0   PCA                                                               03/14/2021 23:43:24 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE PCA
OBJECT MODULE PLACED IN .\out\pca.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\device\pca.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\application;..\device
                    -) DEBUG OBJECTEXTEND PRINT(.\out\Listings\pca.lst) OBJECT(.\out\pca.obj)

line level    source

   1          
   2          #include        "pca.h"
   3          
   4          #ifdef USING_PCA0
   5          bit             B_Capture0;
   6          uint8_t         PCA0_mode;
   7          uint16_t                CCAP0_tmp,PCA_Timer0;
   8          uint16_t        PWM0_low;       //PWM输出低电平的PCA时钟脉冲个数, 用户层不可见。
   9          #endif
  10          #ifdef USING_PCA1
              bit             B_Capture1;
              uint8_t         PCA1_mode;
              uint16_t                CCAP1_tmp,PCA_Timer1;
              uint16_t        PWM1_low;       //PWM输出低电平的PCA时钟脉冲个数, 用户层不可见。
              #endif
  16          #ifdef USING_PCA2
              bit             B_Capture2;
              uint8_t         PCA2_mode;
              uint16_t                CCAP2_tmp,PCA_Timer2;
              uint16_t        PWM2_low;       //PWM输出低电平的PCA时钟脉冲个数, 用户层不可见。
              #endif
  22          
  23          
  24          
  25          
  26          
  27          //========================================================================
  28          // 函数: void PWMn_SetHighReg(unsigned int high)
  29          // 描述: 更新占空比数据。
  30          // 参数: high:  占空比数据，即PWM输出高电平的PCA时钟脉冲个数。
  31          // 返回: 无
  32          //========================================================================
  33          void PWMn_Update(uint8_t PCA_id, uint16_t high)
  34          {
  35   1          #ifdef USING_PCA0
  36   1              if(PCA_id == PCA0)
  37   1              {
  38   2                      if(high > PWM0_HIGH_MAX)        high = PWM0_HIGH_MAX;   //如果写入大于最大占空比数据，强制为最大占空比。
  39   2                      if(high < PWM0_HIGH_MIN)        high = PWM0_HIGH_MIN;   //如果写入小于最小占空比数据，则返回错误代码2。
  40   2                      CR = 0;                                                 //停止PCA。
  41   2                      PCA_Timer0 = high;                              //数据在正确范围，则装入占空比寄存器。
  42   2                      PWM0_low = PWM0_DUTY - high;    //计算并保存PWM输出低电平的PCA时钟脉冲个数。
  43   2                      CR = 1;                                                 //启动PCA。
  44   2              }
  45   1          #endif
  46   1          #ifdef USING_PCA1
                      if(PCA_id == PCA1)
                      {
                              if(high > PWM1_HIGH_MAX)        high = PWM1_HIGH_MAX;   //如果写入大于最大占空比数据，强制为最大占空比。
                              if(high < PWM1_HIGH_MIN)        high = PWM1_HIGH_MIN;   //如果写入小于最小占空比数据，则返回错误代码2。
                              CR = 0;                                                 //停止PCA。
                              PCA_Timer1 = high;                              //数据在正确范围，则装入占空比寄存器。
                              PWM1_low = PWM1_DUTY - high;    //计算并保存PWM输出低电平的PCA时钟脉冲个数。
                              CR = 1;                                                 //启动PCA。
C51 COMPILER V9.59.0.0   PCA                                                               03/14/2021 23:43:24 PAGE 2   

                      }
                  #endif
  57   1          #ifdef USING_PCA2
                      else if(PCA_id == PCA2)
                      {
                              if(high > PWM2_HIGH_MAX)                high = PWM2_HIGH_MAX;   //如果写入大于最大占空比数据，强制为最大占空比。
                              if(high < PWM2_HIGH_MIN)                high = PWM2_HIGH_MIN;   //如果写入小于最小占空比数据，则返回错误代码2。
                              CR = 0;                                         //停止PCA。
                              PCA_Timer2 = high;                                              //数据在正确范围，则装入占空比寄存器。
                              PWM2_low = PWM2_DUTY - high;                            //计算并保存PWM输出低电平的PCA时钟脉冲个数。
                              CR = 1;                                         //启动PCA。
                      }
                  #endif
  68   1      }
  69          
  70          
  71          
  72          //========================================================================
  73          // 函数: UpdatePwm(uint8_t PCA_id, uint8_t pwm_value)
  74          // 描述: 更新PWM值. 
  75          // 参数: PCA_id: PCA序号. 取值 PCA0,PCA1,PCA2,PCA_Counter
  76          //               pwm_value: pwm值, 这个值是输出低电平的时间.
  77          // 返回: none.
  78          //========================================================================
  79          /*
  80          void    UpdatePwm(uint8_t PCA_id, uint8_t pwm_value)
  81          {
  82                  if(PCA_id == PCA0)              CCAP0H = pwm_value;
  83                  else if(PCA_id == PCA1) CCAP1H = pwm_value;
  84                  else if(PCA_id == PCA2) CCAP2H = pwm_value;
  85          }
  86          */
  87          
  88          //========================================================================
  89          // 函数: void   PCA_Init(PCA_id, PCA_InitTypeDef *PCAx)
  90          // 描述: PCA初始化程序.
  91          // 参数: PCA_id: PCA序号. 取值 PCA0,PCA1,PCA2,PCA_Counter
  92          //               PCAx: 结构参数,请参考PCA.h里的定义.
  93          // 返回: none.
  94          //========================================================================
  95          void    PCA_Init(uint8_t PCA_id, PCA_InitTypeDef *PCAx)
  96          {
  97   1              if(PCA_id > PCA_Counter)        return;         //id错误
  98   1      
  99   1              if(PCA_id == PCA_Counter)                       //设置公用Counter
 100   1              {
 101   2                      CR = 0;
 102   2                      CH = 0;
 103   2                      CL = 0;
 104   2                      AUXR1 = (AUXR1 & ~(3<<4)) | PCAx->PCA_IoUse;                    //切换IO口
 105   2                      CMOD  = (CMOD  & ~(7<<1)) | PCAx->PCA_Clock;                    //选择时钟源
 106   2                      CMOD  = (CMOD  & ~1) | (PCAx->PCA_Interrupt_Mode & 1);  //ECF
 107   2                      if(PCAx->PCA_Polity == PolityHigh)              PPCA = 1;       //高优先级中断
 108   2                      else                                                                    PPCA = 0;       //低优先级中断
 109   2                      CR = 1;
 110   2                      return;
 111   2              }
 112   1      
 113   1              PCAx->PCA_Interrupt_Mode &= (3<<4) + 1;
 114   1              if(PCAx->PCA_Mode >= PCA_Mode_SoftTimer)        PCAx->PCA_Interrupt_Mode &= ~(3<<4);
 115   1      
 116   1          #ifdef USING_PCA0
C51 COMPILER V9.59.0.0   PCA                                                               03/14/2021 23:43:24 PAGE 3   

 117   1              if(PCA_id == PCA0)
 118   1              {
 119   2                      CCAPM0    = PCAx->PCA_Mode | PCAx->PCA_Interrupt_Mode;  //工作模式, 中断模式
 120   2                      PCA_PWM0  = (PCA_PWM0 & ~(3<<6)) | PCAx->PCA_PWM_Wide;  //PWM宽度
 121   2      
 122   2                      PCA_Timer0 = PCAx->PCA_Value;
 123   2                      B_Capture0 = 0;
 124   2                      PCA0_mode = PCAx->PCA_Mode;
 125   2                      CCAP0_tmp = PCA_Timer0;
 126   2                      CCAP0L = (uint8_t)CCAP0_tmp;                    //将影射寄存器写入捕获寄存器，先写CCAP0L
 127   2                      CCAP0H = (uint8_t)(CCAP0_tmp >> 8);     //后写CCAP0H
 128   2              }
 129   1          #endif
 130   1          #ifdef USING_PCA1
                      if(PCA_id == PCA1)
                      {
                              CCAPM1    = PCAx->PCA_Mode | PCAx->PCA_Interrupt_Mode;
                              PCA_PWM1  = (PCA_PWM1 & ~(3<<6)) | PCAx->PCA_PWM_Wide;
              
                              PCA_Timer1 = PCAx->PCA_Value;
                              B_Capture1 = 0;
                              PCA1_mode = PCAx->PCA_Mode;
                              CCAP1_tmp = PCA_Timer1;
                              CCAP1L = (uint8_t)CCAP1_tmp;                    //将影射寄存器写入捕获寄存器，先写CCAP0L
                              CCAP1H = (uint8_t)(CCAP1_tmp >> 8);     //后写CCAP0H
                      }
                  #endif
 144   1          #ifdef USING_PCA2
                      if(PCA_id == PCA2)
                      {
                              CCAPM2    = PCAx->PCA_Mode | PCAx->PCA_Interrupt_Mode;
                              PCA_PWM2  = (PCA_PWM2 & ~(3<<6)) | PCAx->PCA_PWM_Wide;
              
                              PCA_Timer2 = PCAx->PCA_Value;
                              B_Capture2 = 0;
                              PCA2_mode = PCAx->PCA_Mode;
                              CCAP2_tmp = PCA_Timer2;
                              CCAP2L = (uint8_t)CCAP2_tmp;                    //将影射寄存器写入捕获寄存器，先写CCAP0L
                              CCAP2H = (uint8_t)(CCAP2_tmp >> 8);     //后写CCAP0H
                      }
                  #endif
 158   1      }
 159          
 160          
 161          //========================================================================
 162          // 函数: void   PCA_Handler (void) interrupt PCA_VECTOR
 163          // 描述: PCA中断处理程序.
 164          // 参数: None
 165          // 返回: none.
 166          //========================================================================
 167          void    PCA_Handler (void) interrupt PCA_VECTOR
 168          {
 169   1          #ifdef USING_PCA0
 170   1              if(CCF0 && PCA0_mode == PCA_Mode_HighPulseOutput)               //PCA模块0中断
 171   1              {
 172   2                      CCF0 = 0;               //清PCA模块0中断标志
 173   2                      if(P25) CCAP0_tmp += PCA_Timer0;        //输出为高电平，则给影射寄存器装载高电平时间长度
 174   2                      else    CCAP0_tmp += PWM0_low;  //输出为低电平，则给影射寄存器装载低电平时间长度
 175   2                      CCAP0L = (uint8_t)CCAP0_tmp;                    //将影射寄存器写入捕获寄存器，先写CCAP0L
 176   2                      CCAP0H = (uint8_t)(CCAP0_tmp >> 8);     //后写CCAP0H
 177   2              }
 178   1          #endif
C51 COMPILER V9.59.0.0   PCA                                                               03/14/2021 23:43:24 PAGE 4   

 179   1          #ifdef USING_PCA1
                      if(CCF1 && PCA1_mode == PCA_Mode_HighPulseOutput)       //PCA模块1中断
                      {
                              CCF1 = 0;               //清PCA模块1中断标志
                              if(P26) CCAP1_tmp += PCA_Timer1;        //输出为高电平，则给影射寄存器装载高电平时间长度
                              else    CCAP1_tmp += PWM1_low;  //输出为低电平，则给影射寄存器装载低电平时间长度
                              CCAP1L = (uint8_t)CCAP1_tmp;                    //将影射寄存器写入捕获寄存器，先写CCAP0L
                              CCAP1H = (uint8_t)(CCAP1_tmp >> 8);     //后写CCAP0H
                      }
                  #endif
 189   1          #ifdef USING_PCA2
                      if(CCF2 && PCA2_mode == PCA_Mode_HighPulseOutput)       //PCA模块2中断
                      {
                              CCF2 = 0;               //清PCA模块2中断标志
                              if(P27) CCAP2_tmp += PCA_Timer2;        //输出为高电平，则给影射寄存器装载高电平时间长度
                              else    CCAP2_tmp += PWM2_low;  //输出为低电平，则给影射寄存器装载低电平时间长度
                              CCAP2L = (uint8_t)CCAP2_tmp;                    //将影射寄存器写入捕获寄存器，先写CCAP0L
                              CCAP2H = (uint8_t)(CCAP2_tmp >> 8);     //后写CCAP0H
                      }
                  #endif
 199   1              if(CF)  //PCA溢出中断
 200   1              {
 201   2                      CF = 0;                 //清PCA溢出中断标志
 202   2              }
 203   1      
 204   1      }
*** WARNING C316 IN LINE 204 OF ..\device\pca.c: unterminated conditionals


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    326    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      7       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
